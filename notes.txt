Okay, I'm going to do a keyer from scratch.  The first thing to do is to
take a contact closure and beep a speaker with it.  Then, I can implement
iambic at a fixed speed.  Then, make improvements.

Since measuring milliseconds is easy, I'll use a twitch (see the keyer notes)
of 1 millisecond.  This corresponds to a standard word of "CODEX".  Anyway,
at the beginning, I will do a contact closure.  The left leg connects to pin
D5, the right leg connects to pin D2.  The speaker is connected to pin D4.

=======================================================================

Progress, I can do an iambic-A keyer, and it sounds the sidetone.  It also
should key the desired line (although I haven't tested that) and it reads a
potentiometer for a speed control and displays that speed control on the LCD.

Next, I need to do three things, in no particular order.  I need to design
the display interface.  I need to split the paddle handling logic out of the
main loop and into a set of classes (one per keying type, straight, bug,
iambic-a, iambic-b, ultimatic, etc) and I need to add commands that I can use
to alter the configuration of the keyer.

To add commands, I need some way of entering commands, so I either need a
serial port, a PS/2 keyboard, or the ability to interpret morse code as sent
by the operator.  I also need to design the commands, so I'll put that off.

Next, I think I want to design the display interface.  Most guys are using
2-line display, each of 16 characters.  I'm using 4-lines, each of 20
characters because I like lots of screen real-estate.  The problem is, I don't
(yet-at any rate) know how to define an interface that works in both cases.

I DO know that I don't want to just display the sent CW.  That's just about
the most useless thing the K3NG software does.

What information do I want to display?  Well, start with the speed.  Also,
which TX is enabled, and whether or not the side tone is on.  How about
whether or not the paddles are reversed.  Also, the mode the keyer is in,
and maybe which memory is transmitting if a memory is transmitting.

I don't think I want to know if the CW is being entered from the paddles, the
keyboard, or a serial port, but I might add that if I don't choose something
else.

Okay, here's my display:
           1         2
  12345678901234567890
 1IamB 25 Tx1S Nor Pad
 2
 3
 4

The other three lines could be like it works now.  The first field is "IamB"
which means "Iambic-B".  The other values would be "IamA" (Iambic-A) " Bug"
(semiautomatic), "Ulti" (Ultimatic) or "Strt" (Straight or "Cootie" Key).

"25" would be the speed in WPM, and could take up to three digits.  "Tx1"
would be which transmitter would be transmitting, which might be "Tx1",
"Tx2",through however many or "CPO" for transmitter off.  The "S" would mean
the sidetone is on.

"Nor" would be normal paddle orientation, and "Rev" would be reverse.

"Pad" would be currently transmitting from the paddles.  Other possible values
would be "KBD" for keyboard, "Ser" for serial port, "Mnn" for memory number nn
or "Rnn" for repeating memory number nn.

Other values I might like to should would be the current serial number,  That
might go on the second row.  Like I said, nothing is more useless than what's
been transmitted.

For a 2x16 display, notice I cunningly made the first four items 16 characters
long, and I can envision scrolling the sent text along the bottom line.  I
might just put text only on the bottom line in any case, figuring that I'll
know what to do with the rest of the lines at some point.

I think that having three scrolling lines is kind of excessive.  I mean, I can
see having scrolling text so that the user can see what's going on, but I
can't see having more than one line scroll.  So, I'm going to make the fields
bigger.

           1         2
  12345678901234567890
 1Iambic Mode A  25wpm
 2Xmitter 1  Tone  800
 3Paddles Reverse
 4

I thought about it, and I think I want to visually display whether or not the
system is in "program" mode.  So, how about this:

           1         2
  12345678901234567890
 1Iambic-A Prog  25wpm
 2Xmitter 1  Tone  800
 3Paddles Reverse
 4

in program mode and

           1         2
  12345678901234567890
 1Iambic-A       25wpm
 2Xmitter 1  Tone  800
 3Paddles Reverse
 4

When not in program mode.

I also want to show the serial number, when that feature is included.  I think
I can put that on the 3rd row.  So, how about this?

           1         2
  12345678901234567890
 1Iambic-A       25wpm
 2Xmitter 1  Tone  800
 3Norm Paddle    #####
 4

--------------------------------------------------

Configuration changes through the keyboard

Ctrl-O toggles the sidetone on and off.  The K3NG software also does \o and CommandMode-o (through paddles)
Ctrl-N toggles the paddle reverse.  The K3NG software also does \n and CommandMode-n (through paddles)


--------------------------------------------------
Okay, memories.  How do I program memories?

Well, the K3NG software uses SHIFT-F1, SHIFT-F2, etc to program memory 1, memory 2, and so forth

It also says that (through a serial connection, and I presume the PS/2 keyboard) you can program memories by doing \p1, \p2, ... \p<n> where "<n>" is the number of memories (12, in my case)

It also says that, in command mode, you can send (through the paddles) P and then one or two digits to program the memory encoded in the digits.  I presume that a single-digit number would have a timeout, or one can use a leading 0.  (I guess.  It doesn't actually say anywhere and I don't feel like digging through the source to figure it out.)

So, I should be able to "p" and either a two-digit number (or a single digit number that times out after a while) to program the memory of the number.

How do I play memories?  Well, \# (or I presume \##) plays the memory encoded by the digit through the serial port.  Pressing the button in normal mode will play the memory, pressing the button in program mode will play the memory through the speaker, but won't key the radio.  Through the PS/2 keyboard, F1, F2, F3, and so forth plays memory 1, 2, 3, and so forth.

Okay, that should be enough to get started.

Of course, how long is the timeout?  I don't think I want to tie it to the speed of the morse.  Let's use one second.

Also, should I eventually have tones indicating things like entering and exiting program mode and when we're programming a memory.

Also, when I'm programming the memory, I should put "Memory" and the memory number into the "transmitter" field, as visual feedback for what is going on.  For the small display, it will be just "M" and the number.  No leading zeroes, and a space after if needed.

So, how will the memories work?  Well, Each byte will be divided into two fields.  The most significan two bits will indicate what sort of byte it is, and the bottom six bits will encode a number.  The most significant two bits will be "00" for end of memory, "01" for "memory macro" (currently not supported), "11" for key down, and "10" for key up.  For end of memory, the bottom six bits will have no meaning until I think of something that it might be useful for.  For the memory macro, it will eventually encode which macro is meant.  For key up and key down, the number will be tenths of a dot time.

Actually, I think I want to first set up the playback of memories with some canned memories, and then work on the programming.  So, let's begin...

...Okay, that works.

Now, to program the memory.  In the original firmware, to program a memory through the paddles, you pushed the command button and then sent a "P" followed by either one or two digits.  The digits set the mode.  It would then record the memory until you pushed the command mode button again.  I should also figure out how to display something to indicate it's recording a memory.

--------------------------------------------------
What Works:
Sidetone Speaker
Speed Control
I2C interface
Memory Buttons

What Doesn't Work:
Key Input

What is unknown:
PTT 1
Key Out 1
Key Out 2
PS/2 Keyboard

Key Out 1:  11
PTT 1: 13
Key Out 2:  12
Paddle Left:  5
Paddle Right: 2
Speaker:  4
PS/2 Keyboard Clock:  3
PS/2 Keyboard Data In:  A3


--------------------------------------------------
TODO:
DONE)  Split the paddle logic out of the main function.

DONE)  Split the serial port handling out of the main function.

DONE)  Split the text to morse functionality out of the serial port handling.

DONE)  add PS/2 Morse keyboard

DONE)  Configuration changes through serial and keyboard.  The first change will be reverse paddles and sidetone toggle

DONE)  Figure out how to do the display strings better.  Maybe with defined constants that only the display class knows how to interpret.  I can't tell the difference between serial port input and keyboard input, so take that into account

DONE)  Set up a mechanism for including or eliminating specified features and options similar to the way K3NG's firmware set does.  This is a big invasive change, so I want to do this soon before things get too far advanced.

DONE)  Read the buttons as a feature

DONE)  Configuration changes through the paddles with a command button.  The first change will be reverse paddles and sidetone toggle

DONE)  If I don't send anything for a while, and the last character is not a space, then the last character on the scrolling display should be a space.

DONE)  Allow the selection of multiple transmitter numbers.  Includes configuration updates and changes to the calls to display.

DONE) PTT Logic, including keyer start delay after PTT asserted.

DONE) Scrolling text as it is sent (although it could use some enhancement)

DONE) Morse through the serial port (although it could use some enhancement)

DONE) I'm having trouble sending KN, figure out why and fix it.  (I modified the paddle scan timing.)

Allow for the programming and playing back of memories.  Make sure that the display shows the memory number on playback.  Also, the morse-to-text should put the text out as it is sent.   Also, put the number of memory bytes remaining on the display.

Add some audio cues for operating without a display.  (Enter program mode, exit program mode, start programming the memory, memory programmed, error condition.  There may be others.)

Figure out how to better do the morse tables so that there aren't remnants hanging around if they aren't needed

Fix the configuration stuff through the PS/2 keyboard.  I'm not doing control characters properly.

Make runtime configurations persistent as a feature

Add a serial number capability to the memorized messages.

Use the backslash as an keyboard command escape key
